import{_ as c,r as e,o as l,c as i,b as s,w as u,d as p,e as n,f as t}from"./app-7eb711a8.js";const r={},d=p(`<h1 id="vue3-响应系统" tabindex="-1"><a class="header-anchor" href="#vue3-响应系统" aria-hidden="true">#</a> Vue3 响应系统</h1><p>响应系统是 Vue 的重要组成部分，它用于实现数据响应式和依赖收集。在 Vue3 中，响应系统是基于Proxy实现的，Proxy API 提供了更加全面的数据拦截操作，这使得 Vue3 中的响应系统更加高效和灵活。</p><h2 id="副作用函数" tabindex="-1"><a class="header-anchor" href="#副作用函数" aria-hidden="true">#</a> 副作用函数</h2><p>在介绍响应式数据之前，我们先来了解一个概念：副作用函数（side effect function）。副作用函数是指那些除了返回值之外，还会对系统的状态产生影响或与外部进行交互的函数。这些影响包括但不限于：</p><ul><li>改变全局变量或者静态变量的值</li><li>修改函数的输入参数</li><li>进行输入/输出操作，例如读写文件或者在控制台上打印信息</li><li>调用其他副作用函数</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&#39;Hello, World!&#39;</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> obj<span class="token punctuation">.</span>text
<span class="token punctuation">}</span>

<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//会在body中写入&#39;Hello, World!&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="响应式原理" tabindex="-1"><a class="header-anchor" href="#响应式原理" aria-hidden="true">#</a> 响应式原理</h2><p>响应式是指当数据发生变化时，能够自动触发相关副作用函数执行的机制。</p><h3 id="基本实现" tabindex="-1"><a class="header-anchor" href="#基本实现" aria-hidden="true">#</a> 基本实现</h3><p>Vue3 采用了 Proxy API 来实现响应式数据。通过 Proxy 创建一个代理对象，该代理对象会拦截对目标对象的访问和修改操作，并在这些操作发生时触发相应的副作用函数执行。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&#39;Hello, World!&#39;</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token function-variable function">track</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">tracked deps </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>target<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token function-variable function">trigger</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">the value of </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> has changed to: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//在这里收集依赖</span>
    <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
    <span class="token comment">//在这里触发依赖</span>
    <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span>

proxy<span class="token punctuation">.</span>text  
<span class="token comment">// &#39;Hello, World!&#39;</span>
<span class="token comment">// 输出：tracked deps { text: &#39;Hello, World!&#39; }</span>
proxy<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">&#39;Hello, Vue3!&#39;</span>
<span class="token comment">// 输出：the value of text has changed to: Hello, Vue3!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的示例简单的实现了响应式数据，当修改代理对象时，会触发相应的副作用函数执行。在Vue3中，真实的响应式数据的实现要复杂得多，需要考虑更多的场景和边界条件以及性能优化，但基本原理还是类似的。</p><h3 id="收集依赖" tabindex="-1"><a class="header-anchor" href="#收集依赖" aria-hidden="true">#</a> 收集依赖</h3><p>在上面的示例中，我们了解了响应式数据的基本实现原理。但是，上面的示例并不完善，它还缺少了一个重要的功能：依赖收集。依赖收集是指在读取响应式数据时，自动收集相关的副作用函数。</p><p>由于响应式数据本身可以是一个简单的对象，也可以是由多个对象嵌套形成的复杂对象，所以最直接的方式便是将响应式数据本身作为键来创建集合，它的值便是和对应属性相关的副作用函数（一个属性可以对应多个副作用函数）的集合，这样便在响应式数据与副作用函数之间建立了联系，以便于之后在修改数据时能够精确的找到副作用函数并执行。</p><p>以下是简单的代码实现：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//使用全局变量来存储副作用函数，匿名函数也可以存储</span>
<span class="token keyword">let</span> currentEffect

<span class="token comment">//用来存储与响应式数据相关副作用函数的集合，WeakMap可以保证当响应式数据被垃圾回收时，对应的副作用函数也会被自动清除</span>
<span class="token keyword">const</span> effectsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">//将收集副作用函数的逻辑封装为一个函数，这样逻辑分离，便于调试</span>
<span class="token keyword">const</span> <span class="token function-variable function">track</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">//如果没有相应的副作用函数，直接 return</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>currentEffect<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">//获取响应式数据所对应的副作用函数的依赖集合</span>
    <span class="token keyword">let</span> depsMap <span class="token operator">=</span> effectsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//创建响应式数据对应的依赖集合</span>
      depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      effectsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> depsMap<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//从响应式数据对应的依赖集合中获取当前属性对应的依赖集合</span>
    <span class="token keyword">let</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//创建响应式数据属性对应的依赖集合</span>
      deps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> deps<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//将当前副作用函数添加到依赖集合中</span>
    deps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>currentEffect<span class="token punctuation">)</span>
    <span class="token comment">//将当前副作用函依赖集合数添加到currentEffect.deps数组中，在后续执行依赖时会用来清理副作用函数</span>
    <span class="token comment">//确保副作用函数都是最新的，避免产生遗留影响</span>
    currentEffect<span class="token punctuation">.</span>deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>deps<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="触发依赖" tabindex="-1"><a class="header-anchor" href="#触发依赖" aria-hidden="true">#</a> 触发依赖</h3><p>在上面的示例中，我们了解了 Vue3 收集依赖的基本原理，在收集好依赖之后，我们还需要在修改响应式数据时，触发相应的副作用函数。</p><p>以下是简单的代码实现：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//将收集副作用函数的逻辑封装为一个函数，这样逻辑分离，便于调试</span>
<span class="token keyword">const</span> <span class="token function-variable function">trigger</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">//获取响应式数据所对应的依赖集合</span>
  <span class="token keyword">const</span> depsMap <span class="token operator">=</span> effectsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">//获取响应式数据属性对应的依赖集合</span>
  <span class="token keyword">const</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">//遍历依赖集合，执行副作用函数</span>
  deps <span class="token operator">&amp;&amp;</span> deps<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">//执行副作用函数</span>
    <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="执行依赖" tabindex="-1"><a class="header-anchor" href="#执行依赖" aria-hidden="true">#</a> 执行依赖</h3><p>在上面的示例中，我们了解了 Vue3 触发依赖的基本原理，在触发依赖对应的副作用函数后，应该清理掉之前所收集的依赖，执行最新收集的依赖。</p><p>以下是简单的代码实现：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//使用全局变量来存储副作用函数，匿名函数也可以存储</span>
<span class="token keyword">let</span> currentEffect

<span class="token comment">//执行副作用函数的逻辑封装为一个函数，这样逻辑分离，便于调试</span>
<span class="token keyword">const</span> <span class="token function-variable function">effect</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">//创建一个副作用函数的实例</span>
  <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">//清理掉上一次收集的依赖</span>
    <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
    <span class="token comment">//将当前副作用函数的实例添加到全局变量中，以便在执行副作用函数时可以获取到</span>
    currentEffect <span class="token operator">=</span> effectFn
    <span class="token comment">//执行副作用函数</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//将副作用函数的实例添加到全局变量中，以便在执行副作用函数时可以获取到</span>
  effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">//执行副作用函数</span>
  <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">//用来清理副作用函数的依赖集合，防止产生遗留影响</span>
<span class="token keyword">const</span> <span class="token function-variable function">cleanup</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">effectFn</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>effectFn<span class="token punctuation">.</span>deps<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//从依赖集合中删除副作用函数</span>
    <span class="token keyword">const</span> deps <span class="token operator">=</span> effectFn<span class="token punctuation">.</span>deps<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    deps<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//重置 effectFn.deps 数组，以便于收集最新的依赖</span>
  effectFn<span class="token punctuation">.</span>deps<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,25),k=n("p",null,"以上代码示例仅用于说明 Vue3 响应式数据的基本实现原理，没有考虑更多的场景和边界条件以及性能优化的方法，并非真实Vue3代码。",-1),v=n("p",null,"真实 Vue3 源代码，请参考：",-1),m={href:"https://github.com/vuejs/",target:"_blank",rel:"noopener noreferrer"},b={href:"https://unpkg.com/vue@3/dist/vue.global.js",target:"_blank",rel:"noopener noreferrer"},f=p('<h2 id="底层原理" tabindex="-1"><a class="header-anchor" href="#底层原理" aria-hidden="true">#</a> 底层原理</h2><p>通过上面的几个示例，我们对 Vue3 响应式数据的基本实现原理已经有了一个基本的了解。接下来，我们来深入探讨一下 Vue3 响应式数据的具体实现原理。</p><h3 id="proxy" tabindex="-1"><a class="header-anchor" href="#proxy" aria-hidden="true">#</a> Proxy</h3><h3 id="reflect" tabindex="-1"><a class="header-anchor" href="#reflect" aria-hidden="true">#</a> Reflect</h3>',4);function h(g,y){const a=e("ExternalLinkIcon"),o=e("Minfo");return l(),i("div",null,[d,s(o,null,{default:u(()=>[k,v,n("ul",null,[n("li",null,[n("a",m,[t("Vue3 Github 仓库"),s(a)])]),n("li",null,[n("a",b,[t("Vue3 CDN"),s(a)])])])]),_:1}),f])}const x=c(r,[["render",h],["__file","01.html.vue"]]);export{x as default};

import{_ as a,o as n,c as s,d as e}from"./app-67a5eec7.js";const t={},p=e(`<h1 id="虚拟-dom" tabindex="-1"><a class="header-anchor" href="#虚拟-dom" aria-hidden="true">#</a> 虚拟 DOM</h1><p>虚拟 DOM 是 Vue 中的一个重要概念，那么什么是虚拟 DOM 呢？简单来说，虚拟 DOM 是一个模拟真实 DOM 属性的普通 JS 对象，它与页面上的真实 DOM 对应，当状态变化页面需要更新时，虚拟 DOM 会通过 diff 算法将更新前后的差异渲染到真实 DOM 上。</p><h2 id="虚拟-dom-的性能" tabindex="-1"><a class="header-anchor" href="#虚拟-dom-的性能" aria-hidden="true">#</a> 虚拟 DOM 的性能</h2><p>虚拟 DOM 本质上还是一个 JS 对象，最终还是会通过操作真实 DOM 完成页面更新，那么它的性能到底如何呢？</p><h3 id="命令式-vs-声明式" tabindex="-1"><a class="header-anchor" href="#命令式-vs-声明式" aria-hidden="true">#</a> 命令式 vs 声明式</h3><p>在早期页面开发时，我们经常使用命令式的写法来更新页面，例如使用 jQuery 或者原生 JS：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//jQuery 写法</span>
<span class="token function">$</span><span class="token punctuation">(</span><span class="token string">&#39;#app&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token string">&#39;hello world&#39;</span><span class="token punctuation">)</span>

<span class="token comment">//原生 JS 写法</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;app&#39;</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">&#39;hello world&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种命令式的写法目的明确，页面更新渲染通过直接对需要改动的真实 DOM 进行操作，不仅符合逻辑而且也十分直观。</p><p>在 Vue 等前端框架出现后，我们更新页面的方式变成了声明式的了，例如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span> text <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>

<span class="token comment">//Vue 写法</span>
<span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">&#39;hello world&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，声明式的写法只需要声明状态（数据），页面更新渲染通过框架生成的虚拟 DOM 和 diff 算法计算得到最终结果，然后替我们操作真实 DOM 完成更新。这种写法十分简洁，省去了我们获取真实 DOM 的过程</p><h3 id="实际性能" tabindex="-1"><a class="header-anchor" href="#实际性能" aria-hidden="true">#</a> 实际性能</h3><p>从上面的例子可以看出：</p><ul><li>命令式更新页面消耗的性能 = 直接操作真实DOM消耗的性能</li><li>声明式更新页面消耗的性能 = JS计算消耗的性能（diff 算法） + 直接操作真实DOM消耗的性能</li></ul><p>在一般情况下，相比于声明式的通过状态更新页面，命令式直接操作真实 DOM 来更新页面似乎性能消耗更小。</p><p>在真实的页面开发中，使用命令式的写法来更新页面时，当状态发生变化后，我们可能无法精确的找到对应的真实 DOM 进行操作，往往会对整个 DOM 进行更新（例如使用 <code>innerHTML</code>），这样做似乎也会造成不必要的性能消耗。使用声明式的写法更新页面时，可以通过 diff 算法来找出更新前后的差异，精确的找到要更改的真实 DOM 进行操作，这样看起来性能也还可以接受。</p><p>由以上分析可以得出结论：<strong>声明式写法的性能不一定好于命令式（即虚拟 DOM 的性能不一定好于直接操作真实 DOM）</strong>。</p><h2 id="为什么需要虚拟-dom" tabindex="-1"><a class="header-anchor" href="#为什么需要虚拟-dom" aria-hidden="true">#</a> 为什么需要虚拟 DOM</h2><p>如果虚拟 DOM 的性能不一定好于直接操作真实 DOM，那么为什么 Vue 还是使用了虚拟 DOM 呢？</p><h3 id="框架设计" tabindex="-1"><a class="header-anchor" href="#框架设计" aria-hidden="true">#</a> 框架设计</h3><p>Vue 框架在设计时不仅需要考虑到框架性能的问题，也要兼顾许多其他方面的问题。例如支持跨平台：Vue 作为一个通用框架，它不仅要考虑到在浏览器环境下使用，也可能会在 app、桌面应用等环境下使用，而真实 DOM 是浏览器环境下特有的，采用虚拟 DOM 就很好的避免了这种情况，通过虚拟 DOM 计算出最终要更新渲染的结果，再由操作不同环境下的 UI 接口将结果渲染到页面，从而为跨平台提供了良好的支持。</p><h3 id="性能保证与可维护性" tabindex="-1"><a class="header-anchor" href="#性能保证与可维护性" aria-hidden="true">#</a> 性能保证与可维护性</h3><p>虚拟 DOM 可以通过框架内部的算法来精确找到更新前后的差异部分从而做到精确的渲染，通过 JS 计算与精确的 DOM 操作来使更新的性能消耗达到最小化，在一定程度上保证了页面更新消耗性能的下限。同时它使我们在更新页面时只用关心状态的变化从而降低了我们开发时的心智负担，避免了大量的操作真实 DOM 从而提升了代码的可维护性。虚拟 DOM 是由此权衡而出的选择。</p>`,23),o=[p];function i(c,r){return n(),s("div",null,o)}const d=a(t,[["render",i],["__file","03.html.vue"]]);export{d as default};

import{_ as o,r as t,o as c,c as l,b as s,w as i,d,e as n,f as e}from"./app-d3341b56.js";const u={},r=d(`<h1 id="vue3-响应系统" tabindex="-1"><a class="header-anchor" href="#vue3-响应系统" aria-hidden="true">#</a> Vue3 响应系统</h1><p>响应系统是 Vue 的重要组成部分，它用于实现数据响应式和依赖收集。在 Vue3 中，响应系统是基于Proxy实现的，Proxy API 提供了更加全面的数据拦截操作，这使得 Vue3 中的响应系统更加高效和灵活。</p><h2 id="副作用函数" tabindex="-1"><a class="header-anchor" href="#副作用函数" aria-hidden="true">#</a> 副作用函数</h2><p>在介绍响应式数据之前，我们先来了解一个概念：副作用函数（side effect function）。副作用函数是指那些除了返回值之外，还会对系统的状态产生影响或与外部进行交互的函数。这些影响包括但不限于：</p><ul><li>改变全局变量或者静态变量的值</li><li>修改函数的输入参数</li><li>进行输入/输出操作，例如读写文件或者在控制台上打印信息</li><li>调用其他副作用函数</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&#39;Hello, World!&#39;</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> obj<span class="token punctuation">.</span>text
<span class="token punctuation">}</span>

<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//会在body中写入&#39;Hello, World!&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="响应式原理" tabindex="-1"><a class="header-anchor" href="#响应式原理" aria-hidden="true">#</a> 响应式原理</h2><p>响应式是指当数据发生变化时，能够自动触发相关副作用函数执行的机制。</p><h3 id="基本实现" tabindex="-1"><a class="header-anchor" href="#基本实现" aria-hidden="true">#</a> 基本实现</h3><p>Vue3 采用了 Proxy API 来实现响应式数据。通过 Proxy 创建一个代理对象，该代理对象会拦截对目标对象的访问和修改操作，并在这些操作发生时触发相应的副作用函数执行。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&#39;Hello, World!&#39;</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token function-variable function">track</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">tracked deps </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>target<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token function-variable function">trigger</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">the value of </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> has changed to: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//在这里收集依赖</span>
    <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
    <span class="token comment">//在这里触发依赖</span>
    <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span>

proxy<span class="token punctuation">.</span>text  
<span class="token comment">// &#39;Hello, World!&#39;</span>
<span class="token comment">// 输出：tracked deps { text: &#39;Hello, World!&#39; }</span>
proxy<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">&#39;Hello, Vue3!&#39;</span>
<span class="token comment">// 输出：the value of text has changed to: Hello, Vue3!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的示例简单的实现了响应式数据，当修改代理对象时，会触发相应的副作用函数执行。在Vue3中，真实的响应式数据的实现要复杂得多，需要考虑更多的场景和边界条件以及性能优化，但基本原理还是类似的。</p><h3 id="收集依赖" tabindex="-1"><a class="header-anchor" href="#收集依赖" aria-hidden="true">#</a> 收集依赖</h3><p>在上面的示例中，我们了解了响应式数据的基本实现原理。但是，上面的示例并不完善，它还缺少了一个重要的功能：依赖收集。依赖收集是指在读取响应式数据时，自动收集相关的副作用函数。</p><p>由于响应式数据本身可以是一个简单的对象，也可以是由多个对象嵌套形成的复杂对象，所以最直接的方式便是将响应式数据本身作为键来创建集合，它的值便是和对应属性相关的副作用函数（一个属性可以对应多个副作用函数）的集合，这样便在响应式数据与副作用函数之间建立了联系，以便于之后在修改数据时能够精确的找到副作用函数并执行。</p><p>以下是简单的代码实现：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span><span class="token number">100</span> <span class="token punctuation">}</span>
<span class="token comment">//设置 data 的代理对象，转变为响应式数据</span>
<span class="token keyword">const</span> proxyData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span><span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token comment">//在这里收集依赖</span>
       <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">)</span>
       <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>
       target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
       <span class="token comment">//在这里触发依赖</span>
       <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>
       <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">//使用全局变量来存储副作用函数，匿名函数也可以存储</span>
<span class="token keyword">let</span> currentEffect

<span class="token comment">//用来存储与响应式数据相关副作用函数的集合，WeakMap可以保证当响应式数据被垃圾回收时，对应的副作用函数也会被自动清除</span>
<span class="token keyword">const</span> effectsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">//修改 data 的代理对象 proxyData 属性value的值</span>
proxyData<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">&quot;Hello World&quot;</span>
<span class="token comment">//执行与 proxyData 相关的副作用函数</span>
<span class="token function">effect</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">the value of data has changed to: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>proxyData<span class="token punctuation">.</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">//执行副作用函数的逻辑封装为一个函数，这样逻辑分离，便于调试</span>
<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//将当前副作用函数的实例添加到全局变量中，以便在执行副作用函数时可以获取到</span>
    currentEffect <span class="token operator">=</span> fn
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">//将收集副作用函数的逻辑封装为一个函数，这样逻辑分离，便于调试</span>
<span class="token keyword">function</span> <span class="token function">track</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//如果没有相应的副作用函数，直接 return</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>currentEffect<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">//获取响应式数据所对应的副作用函数的依赖集合</span>
    <span class="token keyword">let</span> depsMap <span class="token operator">=</span> effectsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//创建响应式数据对应的依赖集合</span>
      depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      effectsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> depsMap<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//从响应式数据对应的依赖集合中获取当前属性对应的依赖集合</span>
    <span class="token keyword">let</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//创建响应式数据属性对应的依赖集合</span>
      deps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> deps<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//将当前副作用函数添加到依赖集合中</span>
    deps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>currentEffect<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="触发依赖" tabindex="-1"><a class="header-anchor" href="#触发依赖" aria-hidden="true">#</a> 触发依赖</h3><p>在上面的示例中，我们了解了 Vue3 收集依赖的基本原理，在收集好依赖之后，我们还需要在修改响应式数据时，触发相应的副作用函数。</p><p>以下是简单的代码实现：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//将收集副作用函数的逻辑封装为一个函数，这样逻辑分离，便于调试</span>
<span class="token keyword">function</span> <span class="token function">trigger</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//获取响应式数据所对应的依赖集合</span>
  <span class="token keyword">const</span> depsMap <span class="token operator">=</span> effectsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">//获取响应式数据属性对应的依赖集合</span>
  <span class="token keyword">const</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token comment">//遍历依赖集合，执行副作用函数</span>
  deps <span class="token operator">&amp;&amp;</span> deps<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effectFn</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">//执行副作用函数</span>
    <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="底层机制" tabindex="-1"><a class="header-anchor" href="#底层机制" aria-hidden="true">#</a> 底层机制</h2><p>通过上面的几个示例，我们对 Vue3 响应系统的基本实现原理已经有了初步的了解。实际上，Vue3 的响应系统的实现不仅依赖于 <code>Proxy</code>，而且还需要用到 <code>Reflect</code>。</p><h3 id="proxy" tabindex="-1"><a class="header-anchor" href="#proxy" aria-hidden="true">#</a> Proxy</h3><p><code>Proxy</code> 是一个内置对象，它提供了一种机制，允许我们创建一个代理对象，并且可以让我们自由定义在访问或修改该代理对象时的一些处理逻辑（副作用函数），代理对象可以拦截对目标对象的访问和修改操作，并在这些操作发生时触发相应的副作用函数执行。</p><p>我们在使用 <code>Proxy</code> 创建代理对象并设置相关的副作用函数时，实际上是使用了 <code>Proxy</code> 对象上所部署的内部方法，这些内部方法如下表所示：</p><table><thead><tr><th>内部方法</th><th>对应处理函数</th><th>描述</th></tr></thead><tbody><tr><td><code>[[GetPrototypeOf]]</code></td><td><code>getPrototypeOf()</code></td><td>获取代理对象的原型对象</td></tr><tr><td><code>[[SetPrototypeOf]]</code></td><td><code>setPrototypeOf(Object)</code></td><td>设置代理对象的原型对象</td></tr><tr><td><code>[[IsExtensible]]</code></td><td><code>isExtensible()</code></td><td>判断代理对象是否可扩展</td></tr><tr><td><code>[[PreventExtensions]]</code></td><td><code>preventExtensions()</code></td><td>阻止代理对象扩展</td></tr><tr><td><code>[[Get]]</code></td><td><code>get(Target,Key,Receiver)</code></td><td>获取代理对象属性值</td></tr><tr><td><code>[[Set]]</code></td><td><code>set(Target,Key,Value,Receiver)</code></td><td>设置代理对象属性值</td></tr><tr><td><code>[[Delete]]</code></td><td><code>deleteProperty(Target,Key)</code></td><td>删除代理对象属性</td></tr><tr><td><code>[[HasProperty]]</code></td><td><code>has(Target,Key)</code></td><td>判断代理对象是否有某个属性</td></tr><tr><td><code>[[OwnPropertyKeys]]</code></td><td><code>ownKeys()</code></td><td>获取代理对象的所有属性</td></tr><tr><td><code>[[GetOwnProperty]]</code></td><td><code>getOwnPropertyDescriptor(Target,Key)</code></td><td>获取代理对象某个属性的属性描述符</td></tr><tr><td><code>[[DefineOwnProperty]]</code></td><td><code>defineProperty(Target,Key,PropertyDescriptor)</code></td><td>定义代理对象某个属性</td></tr><tr><td><code>[[Call]]</code></td><td><code>apply(Target,ThisArg,Arguments)</code></td><td>设置代理对象的 <code>this</code> 指向</td></tr><tr><td><code>[[Construct]]</code></td><td><code>construct(Target,ArgumentsList,NewTarget)</code></td><td>创建代理对象的新实例</td></tr></tbody></table><p>由上表可见，<code>Proxy</code> 对象上所部署的内部方法基本上涵盖了代理对象所支持的所有操作，为 Vue3 响应系统的构建提供了较为全面的支持。</p><h3 id="reflect" tabindex="-1"><a class="header-anchor" href="#reflect" aria-hidden="true">#</a> Reflect</h3><p><code>Reflect</code> 也是一个内置对象，它提供了一组静态方法，这些静态方法与 <code>Proxy</code> 对象上所部署的内部方法相对应，这些静态方法可以用于执行与 <code>Proxy</code> 对象上所部署的内部方法相同的功能，并且可以用于替代 <code>Proxy</code> 对象上所部署的内部方法。</p><p>Vue3 使用 <code>Recflect</code> 的主要作用是：</p><ul><li><p>响应系统的稳定性：<code>Reflect</code> 对象的方法大多与 <code>Object</code> 对象的同名方法行为一致，但是 Recflect 方法调用后会返回一个布尔值，表示方法调用执行的成功与否，不会影响代码继续执行，而 <code>Object</code> 上的方法则会在执行失败时抛出错位，阻塞代码执行。</p></li><li><p>响应数据行为一致性：利用 <code>Reflect</code> 对象方法的第三个参数 <code>receiver</code>，可以指定合适的接收者（或者可以理解为改变源数据 <code>this</code> 的指向），从而保证了代理对象与源数据在行为（方法调用）上的一致性。</p></li></ul><p><code>Reflect</code> 对象上所部署的静态方法如下表所示：</p><table><thead><tr><th>Reflect方法</th><th>对应内部方法</th><th>描述</th></tr></thead><tbody><tr><td><code>Reflect.getPrototypeOf()</code></td><td><code>[[GetPrototypeOf]]</code></td><td>获取代理对象的原型对象</td></tr><tr><td><code>Reflect.setPrototypeOf()</code></td><td><code>[[SetPrototypeOf]]</code></td><td>设置代理对象的原型对象</td></tr><tr><td><code>Reflect.isExtensible()</code></td><td><code>[[IsExtensible]]</code></td><td>判断代理对象是否可扩展</td></tr><tr><td><code>Reflect.preventExtensions()</code></td><td><code>[[PreventExtensions]]</code></td><td>阻止代理对象扩展</td></tr><tr><td><code>Reflect.get()</code></td><td><code>[[Get]]</code></td><td>获取代理对象属性值</td></tr><tr><td><code>Reflect.set()</code></td><td><code>[[Set]]</code></td><td>设置代理对象属性值</td></tr><tr><td><code>Reflect.deleteProperty()</code></td><td><code>[[Delete]]</code></td><td>删除代理对象属性</td></tr><tr><td><code>Reflect.has()</code></td><td><code>[[HasProperty]]</code></td><td>判断代理对象是否有某个属性</td></tr><tr><td><code>Reflect.ownKeys()</code></td><td><code>[[OwnPropertyKeys]]</code></td><td>获取代理对象的所有属性</td></tr><tr><td><code>Reflect.getOwnPropertyDescriptor()</code></td><td><code>[[GetOwnProperty]]</code></td><td>获取代理对象某个属性的属性描述符</td></tr><tr><td><code>Reflect.defineProperty()</code></td><td><code>[[DefineOwnProperty]]</code></td><td>定义代理对象某个属性</td></tr><tr><td><code>Reflect.call()</code></td><td><code>[[Call]]</code></td><td>设置代理对象的 <code>this</code> 指向</td></tr><tr><td><code>Reflect.construct()</code></td><td><code>[[Construct]]</code></td><td>创建代理对象的新实例</td></tr></tbody></table><p><code>Recflect</code> 对象上的静态方法，方法名称和参数与 <code>Proxy</code> 对象上所部署的内部方法一一对应，并且更加稳定和灵活，同样为 Vue3 响应系统的构建提供了较为全面的支持。</p>`,35),k=n("p",null,"本页面代码示例仅用于说明 Vue3 响应式数据的基本实现原理，没有考虑更多的场景和边界条件以及性能优化的方法，并非真实Vue3代码。",-1),v=n("p",null,"真实 Vue3 源代码，请参考：",-1),m={href:"https://github.com/vuejs/",target:"_blank",rel:"noopener noreferrer"},b={href:"https://unpkg.com/vue@3/dist/vue.global.js",target:"_blank",rel:"noopener noreferrer"};function f(y,h){const a=t("ExternalLinkIcon"),p=t("Minfo");return c(),l("div",null,[r,s(p,null,{default:i(()=>[k,v,n("ul",null,[n("li",null,[n("a",m,[e("Vue3 Github 仓库"),s(a)])]),n("li",null,[n("a",b,[e("Vue3 CDN"),s(a)])])])]),_:1})])}const x=o(u,[["render",f],["__file","01.html.vue"]]);export{x as default};

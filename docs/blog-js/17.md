---
category: JavaScript
tag: 垃圾回收

---


# 垃圾回收
在计算机程序中，无论是定义变量或方法，都需要内存将其存储下来，以便在需要时能够访问到它们，但是内存的大小始终是有限的，为了更加高效的利用有限的内存资源，当我们不再需要某个变量或方法时，就要将它们所占用的内存回收（释放），以便为其他的程序提供空间

但是在我们编写 JS 代码时，似乎并没有直接参与到内存管理的工作当中，这是因为 JS 有着自己的内存管理机制，这种内存管理机制是自动的、无形的
>
> 随风潜入夜，润物细无声
> 
就像诗句中描述的一样，在我们编写的程序工作时，JS 引擎已经默默的替我们完成了内存管理的工作

## 内存分配
当我们在 JS 中定义变量时，JS 引擎就已经替我们完成了内存分配的工作
```js
var a = 1;  
//定义了一个数字类型的变量（基本类型），存储在栈中

const obj = {
    name:"obj"  
}
//定义了一个对象（引用类型），将值存储在堆中，引用地址存储在栈中

function foo(){
    console.log("foo"); 
}  
//定义了一个函数（引用类型），将值存储在堆中，引用地址存储在栈中         
```
<Minfo>

关于变量在内存中的存储方式请看 [变量存储方式](/blog-js/09.md) 这一章节

</Minfo>

## 垃圾回收
通过前面章节的学习，我们知道，保存在栈中的变量在使用完后会由系统来自动释放其所占用的内存，而实际保存在堆中的对象却要通过某些机制来控制其内存的释放，垃圾回收算法便是针对那些已经“不在需要”的对象释放它们的内存的机制

垃圾回收算法主要依赖的是 **引用** 的概念，即一个对象如果有访问另一个对象的权限，那么就叫做一个对象对另一个对象的引用，而垃圾回收所作的工作便是找出那些没有被任何其他对象所引用的对象，将其占用的内存释放掉

释放对象所占内存主要有两种方法：
* 引用计数
* 标记清除

### 引用计数
引用计数算法会从根开始遍历，找出所有被引用的对象。当变量被声明并赋值引用了某个对象后，就将该对象的引用次数设置为1，当这个对象又被其他变量引用，就将这个对象的引用次数 `+1`，当引用该对象的变量的值被覆盖时，就将这个的对象的引用次数 `-1`，直到这个对象的引用次数为0时，就将它所占用的内存释放掉

```js
let o = {value:2};   //
let a = {
    b:{
        c:2
    }
}    //在内存中，对象{b:{c:2}}被变量a引用，而对象{c:2}又被a的属性b引用
let o = a;  //此时
```
### 标记清除
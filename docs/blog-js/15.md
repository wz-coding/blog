---
date: 2023-09-01
category: JavaScript
tag: this 指向

---


# this 指向
**this** 的指向是 JS 中一个十分重要的知识，理解清楚 `this` 的指向问题可以帮助我们更好的理解 JS 中代码的运行逻辑，避免许多不必要的错误
## 什么是this
**this** 关键字我们在开发需求编写代码时经常会用到它，但是 `this` 的理解却比较抽象，下面引用一段 w3school 对于 `this` 关键字的描述：
> In JavaScript, the this keyword refers to an object.
>
> Which object depends on how this is being invoked (used or called).
>
> The this keyword refers to different objects depending on how it is used

简单来说，`this` 是一个对象，代表了函数的调用者（函数的执行上下文对象），而 `this` 的值则取决于这个函数是如何被调用的
## 为什么用 this
可以先观察下面一段代码：
```js
//我有一个电话，自带充电器，充电器只能给我的电话充电
const myPhone = {
    battery:"50%",
    charge:function(){
       //将当前电话的电量充满到100%
       this.battery = "100%"
    }
}

//你也有一个电话，但是没有充电器
const yourPhone = {
    battery:"30%"
}

//我的电话电量不足，需要充电
myPhone.charge();
//电量充满了100% 
console.log(myPhone.battery);  // 100%

//你也想充电，但是不想重新买充电器，只好从我这里借用了充电器
myPhone.charge.call(yourPhone);
//电量也充满了100%
console.log(yourPhone.battery);  //100%
```
从上面的代码可以看出，使用 this 关键字可以很方便的使我们能够读取到其他对象的属性或者方法，极大的方便了我们对于方法的重复利用，减少了许多代码量


## 确定 this 指向
**this** 的指向通常可以分为以下两类：
* 全局环境：  
  在全局环境中 `this` 指向的是全局对象，浏览器中指向了全局对象 `window`，NodeJs中指向了全局对象 `global`，严格模式下则是 `undefined`
* 函数环境：
  在函数环境（局部环境）中 `this` 的指向就要看这个函数是如何被调用的，不同的调用方式会导致 `this` 的指向不同

```js
function getName(){
    const name = "Mike";
    console.log(this.name)
}

var name = "John";
const person = {name:"Blob"};

getName();  // John（this 指向了全局对象 window）

getName.call(person);  //Blob （this 指向了普通对象 person）
```
## 改变 this 指向
函数在被调用时，this 的指向并非是固定不变的，JS 中为我们提供了 3 种方法来改变 this 的指向：
* `call()`：以给定的 `this` 值和逐个提供的参数调用该函数
   
* `apply()`：以给定的 `this` 值和作为数组（或类数组对象）提供的 `arguments` 调用该函数
   
* `bind()`：创建一个新函数，当调用该新函数时，它会调用原始函数并将其 `this` 关键字设置为给定的值，同时，还可以逐个传入参数，这些参数会插入到调用新函数时传入的参数的前面

```js
var count = "0";
const counter = {
     count:0,
     add:function(num){
         this.count += num;
     }
}
counter.add(1);
console.log(counter.count);    //1

const newCounter = {
     count:2
}

// call() 方法改变 this 指向
counter.add.call(newCounter,1);
console.log(newCounter.count); //3

// apply() 方法改变 this 指向
counter.add.apply(newCounter,[1]);
console.log(newCounter.count); //4

const newAdd = counter.add;
//直接调用方法 this 指向全局
newAdd(1);
console.log(this.count);   // "01"
console.log(counter.count); //1

// bind() 方法改变 this 指向
const bindAdd = newAdd.bind(newCounter,1);
bindAdd();
console.log(newCounter.count); //5
```  
  
## 绑定规则
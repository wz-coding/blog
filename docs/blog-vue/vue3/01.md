---
date: 2024-01-08
category: 
   - Vue
   - Vue3
tag: Vue3 响应系统

---

# Vue3 响应系统

响应系统是 Vue 的重要组成部分，它用于实现数据响应式和依赖收集。在 Vue3 中，响应系统是基于Proxy实现的，Proxy API 提供了更加全面的数据拦截操作，这使得 Vue3 中的响应系统更加高效和灵活。

## 副作用函数
在介绍响应式数据之前，我们先来了解一个概念：副作用函数（side effect function）。副作用函数是指那些除了返回值之外，还会对系统的状态产生影响或与外部进行交互的函数。这些影响包括但不限于：

* 改变全局变量或者静态变量的值
* 修改函数的输入参数
* 进行输入/输出操作，例如读写文件或者在控制台上打印信息
* 调用其他副作用函数

```js
const obj = { text: 'Hello, World!' }
function effect() {
  document.body.innerText = obj.text
}

effect()  //会在body中写入'Hello, World!'
```
## 响应式原理
响应式是指当数据发生变化时，能够自动触发相关副作用函数执行的机制。
### 基本实现
Vue3 采用了 Proxy API 来实现响应式数据。通过 Proxy 创建一个代理对象，该代理对象会拦截对目标对象的访问和修改操作，并在这些操作发生时触发相应的副作用函数执行。

```js
const obj = { text: 'Hello, World!' }
const track = (target, key)=> { console.log(`tracked deps ${target}`) }
const trigger = (target,key,value)=> { console.log(`the value of ${key} has changed to: ${value}`) }
const proxy = new Proxy(obj, {
  get(target, key) {
    //在这里收集依赖
    track(target, key)
    return target[key]
  },
  set(target, key, value) {
    target[key] = value
    //在这里触发依赖
    trigger(target,key,value)
    return true
  }  
})

proxy.text  
// 'Hello, World!'
// 输出：tracked deps { text: 'Hello, World!' }
proxy.text = 'Hello, Vue3!'
// 输出：the value of text has changed to: Hello, Vue3!
```
上面的示例简单的实现了响应式数据，当修改代理对象时，会触发相应的副作用函数执行。在Vue3中，真实的响应式数据的实现要复杂得多，需要考虑更多的场景和边界条件以及性能优化，但基本原理还是类似的。

### 收集依赖
在上面的示例中，我们了解了响应式数据的基本实现原理。但是，上面的示例并不完善，它还缺少了一个重要的功能：依赖收集。依赖收集是指在读取响应式数据时，自动收集相关的副作用函数。
        
由于响应式数据本身可以是一个简单的对象，也可以是由多个对象嵌套形成的复杂对象，所以最直接的方式便是将响应式数据本身作为键来创建集合，它的值便是和对应属性相关的副作用函数（一个属性可以对应多个副作用函数）的集合，这样便在响应式数据与副作用函数之间建立了联系，以便于之后在修改数据时能够精确的找到副作用函数并执行。

以下是简单的代码实现：   
```js
const data = { value:100 }
//设置 data 的代理对象，转变为响应式数据
const proxyData = new Proxy(data,{
    get(target,key){
       //在这里收集依赖
       track(target,key)
       return target[key]
    },
    set(target,key,value){
       target[key] = value
       //在这里触发依赖
       trigger(target,key,value)
       return true
    }
})
//使用全局变量来存储副作用函数，匿名函数也可以存储
let currentEffect

//用来存储与响应式数据相关副作用函数的集合，WeakMap可以保证当响应式数据被垃圾回收时，对应的副作用函数也会被自动清除
const effectsMap = new WeakMap()

//修改 data 的代理对象 proxyData 属性value的值
proxyData.value = "Hello World"
//执行与 proxyData 相关的副作用函数
effect(console.log(`the value of data has changed to: ${proxyData.value}`))

//执行副作用函数的逻辑封装为一个函数，这样逻辑分离，便于调试
function effect(fn) {
    //将当前副作用函数的实例添加到全局变量中，以便在执行副作用函数时可以获取到
    currentEffect = fn
    fn()
}

//将收集副作用函数的逻辑封装为一个函数，这样逻辑分离，便于调试
function track(target, key) {
  //如果没有相应的副作用函数，直接 return
  if(!currentEffect) return
  //获取响应式数据所对应的副作用函数的依赖集合
    let depsMap = effectsMap.get(target)
    if(!depsMap) {
      //创建响应式数据对应的依赖集合
      depsMap = new Map()
      effectsMap.set(target, depsMap)
    }
    //从响应式数据对应的依赖集合中获取当前属性对应的依赖集合
    let deps = depsMap.get(key)
    if(!deps) {
      //创建响应式数据属性对应的依赖集合
      deps = new Set()
      depsMap.set(key, deps)
    }
    //将当前副作用函数添加到依赖集合中
    deps.add(currentEffect)
}

```

### 触发依赖
在上面的示例中，我们了解了 Vue3 收集依赖的基本原理，在收集好依赖之后，我们还需要在修改响应式数据时，触发相应的副作用函数。
    
以下是简单的代码实现：    
```js
//将收集副作用函数的逻辑封装为一个函数，这样逻辑分离，便于调试
function trigger (target, key, value) {
  //获取响应式数据所对应的依赖集合
  const depsMap = effectsMap.get(target)
  if(!depsMap) return
  //获取响应式数据属性对应的依赖集合
  const deps = depsMap.get(key)
  if(!deps) return
  //遍历依赖集合，执行副作用函数
  deps && deps.forEach(effectFn=> {
    //执行副作用函数
    effectFn()
  })
}
```

<Minfo>

以上代码示例仅用于说明 Vue3 响应式数据的基本实现原理，没有考虑更多的场景和边界条件以及性能优化的方法，并非真实Vue3代码。

真实 Vue3 源代码，请参考：

* [Vue3 Github 仓库](https://github.com/vuejs/)
* [Vue3 CDN](https://unpkg.com/vue@3/dist/vue.global.js)

</Minfo>

## 底层机制
通过上面的几个示例，我们对 Vue3 响应系统的基本实现原理已经有了初步的了解。实际上，Vue3 的响应系统的实现不仅依赖于 Proxy，而且还需要用到 Reflect。

### Proxy
Proxy 是一个内置对象，它提供了一种机制，允许我们创建一个代理对象，该代理对象可以拦截对目标对象的访问和修改操作，并在这些操作发生时触发相应的副作用函数执行。
Vue3 的响应式数据是基于 Proxy 的，那么什么是 Proxy 呢？简单来说，Proxy 可以创建一个代理对象，通过这个代理对象能够实现对其他对象的 **代理**。
   
那么什么又是代理呢？简单来说，代理（或者也可以叫做 **拦截**）指的是对一个对象的属性操作的代理（拦截）。通过 Proxy 定义代理对象后我们可以拦截并重新定义对一个对象的操作逻辑，这里的操作包括读取对象的属性值，修改对象的属性值，方法调用，对象的方法调用等。

```js
const obj = { 
    value:100,
    add:function(){
       this.value += 1
    }
}
const proxyObj = new Proxy(obj,{
  //在这里拦截读取对象属性的操作
  get(target,key){ 
    console.log(`get ${key}`) 
    return target[key]
  },

  //在这里拦截设置对象属性的操作
  set(target,key,value){ 
    console.log(`set ${key} to value: ${value}`) 
    target[key] = value
  },
  //在这里拦截方法的调用
  apply(target,context,arguments){ 
    console.log(`invoke function`)
    target.call(context,...arguments)
  }
})
//读取对象的属性值
proxyObj.value //100
//修改对象的属性值
proxyObj.value = 101
//调用对象的方法
proxyObj.add() 

const info = () =>{
    console.log(obj.value)
}
const proxyInfo = new Proxy(info,{
  //在这里拦截方法的调用
  apply(target,context,arguments){ 
    console.log(`invoke function ${target}`)
    target.call(context,...arguments)
  } 
})

//调用方法
proxyInfo()  //102
```
以上的示例简单介绍了代理对象的一些简单操作，这些操作都有一个共同点，就是当只有在操作代理对象时，才能触发我们自定义的代理对象的操作逻辑，而当我们操作源对象时，则我们自定义的操作逻辑不会触发



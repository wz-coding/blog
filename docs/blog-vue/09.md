---
date: 2024-01-09
category: 
   - Vue
   - Vue3
tag: Diff 算法

---

# Diff 算法
diff 算法是 Vue 渲染器的核心算法，它的目的是当页面或者组件将要更新时，比较新旧两组 vnode（虚拟dom）节点，并以最小的性能开销完成更新操作（能够复用的节点尽量复用，没办法复用的节点再进行 dom 操作）

假设现在有一组 vnode 需要更新：
```js
//旧的 vnode
const oldVnode = {
   type:'div',
   children:[
      { type:'p',children:'1' },
      { type:'p',children:'2' },
      { type:'p',children:'3' },
      { type:'p',children:'4' },
   ]
}

//新的 vnode
const newVnode = {
   type:'div',
   children:[
      { type:'p',children:'1' },
      { type:'p',children:'4' },
      { type:'h1',children:'3' },
      { type:'p',children:'2' },
   ]
}
```
如果不使用 diff 算法直接对新旧 vnode 进行更新操作，那么就要先卸载旧的 3 个子节点，在挂载新的 3 个子节点，一共要执行 6 次操作，这样移除在创建 dom 元素的操作会造成极大的性能开销。下面将探究使用 diff 算法是如何减小操作 dom 的性能开销的。

<Minfo>

这里在更新节点时没有提到使用 `innerHTML` 接口是因为这样做会存在一些问题：
- `innerHTML` 会将容器内所有节点全部清空，但容器的内容可能是由许多其他组件渲染的，这样做不能正确的执行这些组件的 `beforeUnmount`、`unmounted` 等生命周期函数。
- 容器当中的元素可能存在自定义指令，直接清空就不能触发对应的指令钩子函数。
- `innerHTML` 清空元素时不会移除元素上绑定的事件处理函数。

</Minfo>

## patch 方法
在探究 diff 算法之前，还应当了解 Vue 渲染器中的另一个重要的方法: patch，不同于 diff 算法，patch方法的作用是将 diff 算法中新旧子节点有差异的部分（即需要进行 dom 操作更新的部分）更新到页面上。它的简易版实现如下：
```js
//n1 代表旧的 vnode
//n2 代表新的 vnode
//container 代表容器元素，vnode 的容器
//anchor 代表锚点元素，插入 vnode 时的实用的锚点
function patch(n1, n2, container, anchor){
   //如果旧的 vnode 存在并且与新的 vnode 是不同类型
   if(n1 && n1.type !== n2.type){
      //卸载清空旧的 vnode
      unmount(n1)
      n1 = null
   }
   
   //获取新的 vnode 的类型
   const { type } = n2
   //如果新的 vnode 类型是字符，表示新的 vnode 是一个 dom 元素
   if(typeof type === 'string'){
      if(!n1){
         //如果不存在旧的 vnode，那么直接挂载新的 vnode
         mountElement(n2, container, anchor)
      }else{
         //否则比较新旧 vnode 的差异在进行更新操作
         patchElement(n1, n2)
      }
   }
   //如果新的 vnode 是文本类型
   else if(type === Text){
      if(!n1){
         //如果不存在旧的 vnode，那么直接创建新的文本节点，使新的 vnode 保持对其引用然后插入到页面
         const el = n2.el = document.createTextNode(n2.children)
         insert(el, container, anchor)
      }else{
         //如果存在旧的 vnode，那么直接使用新的 vnode 的文本内容更新旧的 vnode 的文本内容
         const el = n2.el = n1.el
         if(n2.children !== n1.children){
            el.nodeValue = n2.children
         }
      }
   }

   //....
   //省略部分逻辑
}

function mountElement(vnode, container, anchor){
   //获取到 vnode 对应的 真实 dom 元素
   let el = vnode.el 

   //....
   //省略部分处理逻辑
   
   // 将 dom 元素插入到容器中（透传锚点元素给 insert 函数）
   insert(el, container, anchor)
}

function unmount(vnode){
   //获取 vnode 对应 dom 元素的父元素
   const parent = vnode.el.parent
   if(parent){
      //从父元素中卸载 vnode 对应的真实 dom 元素
      parent.removeChild(vnode.el)
   }
}

function patchElement(n1, n2){
   //新的 vonde 也引用了真实 dom
   const el = n2.el = n1.el
   //....
   //其他处理逻辑此处省略
}

```
## 简单 diff

## 双端 diff
## 快速 diff